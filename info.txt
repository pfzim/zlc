zlc (z language compiler) 2008 (c)oded by dEmon

Dmitry V. Zimin <pfzim@mail.ru>

Данный интерпретатор создан для легкого встраивания в программы
и быстрого расширения функционала программ без перекомпиляции.
Прозрачная работа с внешними переменными. Глобальные переменные
доступны между вызовами и не сбрасывают свои значения. Вызможно
вызвать любую функцию из скрипта.

Функциональные возможности:
1. Компиляция
2. Исполнение скомпилированного кода
3. Отладочная декомпиляция

Компиляция:
1. Удобное и быстрое добавление новых функций в интерпретатор
   (таблица внешних функций создаётся перед помпиляцией).

Исполнение кода:
1. Создание и формирование (заполение начальными значениями) стека
   Переменные кладутся в стек в соответствии с их порядком определения
   в функции.

zl_stack_create(&stack, &esp);
zl_stack_push(&stack, &esp, argc);
zl_stack_push(&stack, &esp, argv);
zl_execute(hard_code, &stack, data_table, fn_list, "main");
zl_stack_free(&stack);

Blah... Вспомнил. Хотел сделать взаимодействие с внешними переменными из программы.
Через стек это не получится. Только если передавать адрес переменной.

Для внешних переменных делать двойное извлечение указателя. Адреса внешних и
глобальных переменных будут храниться в карте памяти (или ?стеке - не
получится использовать в функциях).

Всё-таки предлагаю хранить глобальные переменные в области данных, особенно
инициализированные. Их значения записывать сразу с область данных, дабы
избежать лишних операций.

Секции:
0. [.code]	- Код
1. [.const]	- Константные строки
2. [.data]	- Глобальные переменные инициализированные и не инициализированные
3. [.reloc]	- Внешних переменных адреса

В итоге объеденить все секции, а все операции в code будут производиться
относительно начала кода (относительно нуля).

Для этого нужны таблицы посткомпиляционной корректировки смещений jumps-labels,
calls-funcs, vars-relocs, pushs-data.

Разбиение на 4 секции даёт возможноть выбирать какие секции будут глобальными,
а какие локальными для потока.
Например в случае с proxy_rd секции code, const, data будут глобальными, а
секция reloc локальная для каждого потока. Такое поведение будет
действительно для большенства приложений.

funcs_table - объеденить с jumps_table и labels_table. При определении функции
писать её офсет и значение в labels_table, при вызове писать офсет точки вызова
и название функции в jumps_table. На выходе нужна карта функций, для дальнейшего
их вызова по имени.

*** новая версия ***

push data	(офсет относительно таблицы данных)
push imm	(значение)
push reg	(офсет относительно таблицы регистров)
push mem	(офсет относительно карты памяти - изменить.
			 офсет относительно таблицы данных с извлечением значения?)
push pmem	(офсет относительно таблицы данных и последующее извлечение
			 указателя. используется для внешних переменных)

*** старая версия ***

push data	(офсет относительно таблицы данных)
push imm
push reg	(офсет относительно таблицы регистров)
push mem	(офсет относительно карты памяти)

***

На выходе компилятор формирует:
hardcode		- таблица с "жёстким" кодом;
data_table		- таблица с данными (строковые константы)
vars_map		- карта внешних переменных в map_table
//vars_count	- общее количество переменных

map_table		- карта памяти создаётся из vars_map

hardcode, data_table - постоянные для всех потоков процесса, которые будут
исполнять скомпилированный код.
vars_map - постоянный. требуется для создания карты памяти в каждом потоке.
map_table - для каждого треда свой.

//Высчитываются из карты внешних переменных и общего количества переменных:
//vars_ext    - количество внешних переменных
//vars_int    - количество внутренних переменных

Массив map_table формируется динамически после компиляции.
Размер массива равен количеству внешних и глобальных переменных,
используемых в скрипте, и сумме объемов используемыми этими
переменными и массивами. Первая часть заполнятеся адресами 

После чего заполняется адресами внешних переменных в соответствии с
картой внешних переменных, а незаполненные ячейки карты заполняются
адресами из временно создаваемого массива intvars[vars_int+].

Во время компиляции:
zlval hardcode;

offset = cl_data_add(&data_table, data, size)
Строковые константы добавляются в таблицу данных и на выходе функция
возвращает офсет занесённых данных относительно начала таблицы.

names_map *cl_label_define(&labels_table, name, hardcode.fill);
Метки при определении заносятся во временную таблицу (имя метки и её
офсет относительно hardcode)

names_map *cl_jump_define(&jumps_table, name, hardcode.fill);
по коду функция равна cl_label_define()
Переходы на метки заносятся в таблицу аналогично самим меткам (имя метки
и офсет на место в коде, где на ней ссылка).

cl_jump_fix(hardcode, jumps_table, labels_table)
После окончания компиляции все места переходов на метки корректируются в
соответствии с таблицей меток.

names_map *cl_label_new(&jumps_table, hardcode.fill)
Генерирует уникальное значение метки и помещает его в таблицу типа
names_map. И возвращает указатель на структуру.

void *cl_stack_push(&cl_stack, data)
Помещает значение в стек

void *cl_stack_pop(&cl_stack, data)
Возвращает значение из стека

cl_push(hardcode, OP_CALL)
Добавляет код

cl_push_dw(hardcode, (unsigned long) 0)
Добавляет код

unsigned long cl_var_define(&vars_table, name, INTERNAL | EXTERNAL)
Добавляет новую переменную в карту памяти.
После компиляции из этой таблицы сформируется карта внешних переменных и два значения - количество внешних и внутренних переменных.





*** script example ******************************

extern unsigned long external_var1;
unsigned long global_var1;

void some_func(int param1, char *param2)
{
	// высчитывать максимальную глубину стека

	unsigned long local_var1;	// level 0

	{
		unsigned long local_var1;	// level 1
		unsigned long local_var2;	// level 1
		{
			unsigned long local_var1;	// level 2
			unsigned long local_var2;	// level 2
		}
		{
			// здесь переменные будут использовать теже ячейки
			// в стеке, что и в предыдущем блоке
			unsigned long local_var1;	// level 2
			unsigned long local_var2;	// level 2
		}
	}

	// в это примере глубина стека составит 5 переменных.

	return;
}

int main(int argc, char *argv[ ])
{
	_asm
	{
		push ebp
		mov ebp, esp
		sub esp, local_vars_buffer_size
		push all_other_registers
	}

	return 0;

	_asm
	{
		pop all_other_registers
		add esp, local_vars_buffer_size
		pop ebp
	}
}


*** hard code map ******************************

.code section
	lb_entry_point:
		jmp lb_start
		// here service information
		// 4 bytes - next data offset (default 0)
		// 4 bytes - code secton offset
		// 4 bytes - const secton offset
		// 4 bytes - data secton offset
		// 4 bytes - import secton offset
		// 4 bytes - reloc secton offset
		// 4 bytes - export secton offset
		// maybe .export and .map section place here
	lb_start:
		push 0 - default value
		push 0 - default value
		call main
		$end
	some_func:
		push ebp
		mov ebp, esp
		sub esp, local_vars_buffer_size
		push all_other_registers

		// user code here

		pop all_other_registers
		add esp, local_vars_buffer_size
		pop ebp

		ret
		$end
	main:
		push ebp
		mov ebp, esp
		sub esp, local_vars_buffer_size
		push all_other_registers

		// user code here

		push data	(офсет относительно секции .const - в стек кладётся адрес ячейки (значения))
		push imm	(в стек помещается непосредственно значение)
		push reg	(офсет относительно таблицы регистров)
		push mem	(офсет относительно секции .data - в стек клаётся адрес ячейки с данными.
					 используется для глобальных переменных)
		push pmem	(офсет относительно секции .reloc - в стек клаётся значение из таблицы.
					 используется для внешних переменных)

		push 3
		push 2
		push 1
		call near some_func		(близкий вызов. параметр: офсет функции относительно секции .code)
		add esp, 12				(стек чистит вызывающая функция - кол-во переданных параметров * 4)
								(предусмотреть возможность __cdecl и __stdcall, а так же создание
								 naked функций)

		push 3
		push 2
		push 1
		call far GetDC			(дальний вызов. параметр: офсет относительно секции .import)
								(стек чистит вызванная функция (на самом деле внутренняя процедура zlc))

		pop all_other_registers
		add esp, local_vars_buffer_size
		pop ebp

		ret
		$end

.const section (read only, one for all)
		// строковые константы
		// (в коде передача адреса этих данных)
		строка ноль
		строка ноль
		...
		строка ноль
.data section (read, write, usually one for all)
		// глобальные переменные инициализированные и неинициализированные
		// (в коде передача адреса этих данных)
		пустой массив для хранения данных
		(возможно частично инициализированный)
.import section (read only, must be fixed before run, usually one for all)
		// тоже самое, что и .reloc, только для функций
		// дополнительно хранит кол-во переменных передаваемых функции
		// и флаг - значение кто очищает стек
		адрес внешней функции
		количество параметров принммаемых функцией
		флаг сообщающий кто очицает стек
		...
		адрес внешней функции
		количество параметров принммаемых функцией
		флаг сообщающий кто очицает стек
.reloc section (read only, must be fixed before run)
		// указатели на внешние переменные (в коде передача значения из
		// этой таблицы)
		адрес внешней переменной
		адрес внешней переменной
		...
		адрес внешней переменной

.export section (read only, only for external use)
		// карта секции .code
		// используется для вызова внутренних функций снаружи
		// информация о внутренних функциях (смещение, название,
		// опционально кол-во переменных)
		название функции
		адрес функции относительно hard_code
		количество параметров принимаемых функцией
		...
		название функции
		адрес функции относительно hard_code
		количество параметров принимаемых функцией
.map section (read only, only for external use)
		// карта секций .reloc и .import
		// используется для корректировки таблиц
		// информация о внешних переменных их адрес в секции .reloc
		// информация о внешних функциях их секции .reloc (адрес,
		// название, библиотека)
		флаг - тип данных (переменная внешняя, внешняя функция)
		адрес относительно .reloc или .import
		название переменной или функции
		название библиотеки
		...
		флаг - тип данных (переменная внешняя, внешняя функция)
		адрес относительно .reloc или .import
		название переменной или функции
		название библиотеки


*** $end ******************************

zl_stack_create(&stack, 65550);

zl_execute(hard_code, &stack, data_table, reloc_table);

zl_stack_push(&stack, argc);
zl_stack_push(&stack, argv);
zl_call(hard_code, &stack, data_table, reloc_table, funcs_map, "main");
zl_stack_pop(&stack);
zl_stack_pop(&stack);

zl_stack_free(&stack);


Возникает вопрос, как быть с адресами внешних функций?

Хорошо бы не тащить за собой количество переменных передаваемых
внешним функциям. Может сразу делать ассемблерную вставку в 
hard code?



В связи с выше изложенными изменениями в интерпритаторе во время
компиляции будут создаваться отдельные секции - кода, констант,
глобальных переменных, внешних переменных, импортируемых и
экспортируемых функций.

После компиляции происходит объеденение секций и корректировка
ссылок в коде.

stub_code
hard_code
const_table - imm_table
data_table - vars_table
labels_table - jumps_table
funcs_table - calls_table (?внешние и внутренние вызовы)


ВАЖНО! Обратить внимание на генератор новых меток. Там может
быть ошибка в номерах генерируемых меток.

Пример кода без секций (immediatly execute):

int main(int a, int b)
{
	unsigned long c;

	if(a > 32)
	{
		c = 1;
	}
	else
	{
		c = 0
	}

	return b+c;
}

Byte-code:
	jmp lb_start
		// служебная информация (не требуется в данном примере)
lb_start:
	push 0
	push 0
	call main
	$end
main:
	push ebp
	mov ebp, esp
	add esp, 4

	mov eax, [ebp-4]	// или [ebp], ну суть понятна
	cmp eax, 32
	jne @1
	mov [ebp], 1		// или [ebp+4]
	jmp @2
@1:
	mov [ebp], 0		// или [ebp+4]
@2:
	mov ecx, [ebp-8]
	mov edx, [ebp]
	xor eax, eax
	add eax, ecx
	add eax, ebx

	sub esp, 4
	pop ebp

	ret
	$end
	// пустые секции



Во время компиляции:

Информация, которая должна храниться о переменной:
	- имя
	- тип (флаги)
	? общий размер (вычисляется из типа, а у массива равен уровню 0 [правильнее будет сказать last_level])
	- оффсет (для локальной относительно ebp, для глобальной относительно секции .data)
	- глубина блока (level)
	если это массив:
	  - количество уровней
	  - размер каждого уровня
	для гобальных переменных дополнительно
	  - references
	  - reference_offsets

Информация, которая должна храниться о метках и функциях:
	- имя
	- оффсет
	? номер функции (предотвращение прыжков между метками функций) метки очищаются после выхода из функции как и локальные переменные
	- флаги (метка, функция внешняя или внутренняя)
	- references
	- reference_offsets
	для функций:
	  - сумма длинн аргументов (для очистки стека)
	для внешних функций:
	  - имя библиотеки

	jmp near [signed long] (вычисляется как оффсет метки минус место вызова)
	call near [unsigned long] для локальных функций сделать как jmp?
	call far [unsigned long]

Информация, которая должна храниться о строках-константах:
	- строка
	- reference_offset (откуда ссылаемся на строку)


Вроде с метками разобрался.
Надо теперь разобраться с внутренними и внешними функциями,
переменными (массивы, структуры).
Определиться с типом $$.

- При корректировки таблицы импорта функций исключить двойную загрузку библиотек.
- Реализовать правило *expr и (cast_type).
- Сделать Си совместимые объявления функций.
- Добавить возможность объявлять структуры.
- Сделать возможность вызова внешних функций по их адресу (как я понимаю это уже далеко не псевдокод).
- Переделать порядок укладывания параметров в стек при вызове функций.
- Реализовать директивы препроцессора (define, ifdef, ifndef, else, endif)
- Сделать возможность подключать внешние модули (include)
- Требуется много памяти под стек для выполнения много-поточных приложений типа proxy_rd.
- Реализовать операции с плавающей точкой.
